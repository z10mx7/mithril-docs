---
title: "Utility Functions"
description: "Comprehensive utility functions for hashing, encryption, and common operations"
---

# Utility Functions

Mithril provides a comprehensive set of utility functions for common operations including hashing, encryption, string manipulation, time handling, and more.

## Hashing Functions

### Password Hashing

```go
// pkg/utils/hash.go
package utils

import (
    "golang.org/x/crypto/bcrypt"
    "golang.org/x/crypto/argon2"
    "crypto/sha256"
    "crypto/sha512"
    "crypto/hmac"
    "encoding/hex"
)

// Bcrypt hashing
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func CheckPasswordHash(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// Argon2 hashing (more secure)
func HashPasswordArgon2(password string) (string, error) {
    salt := GenerateRandomBytes(16)
    hash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)
    
    // Combine salt and hash
    combined := make([]byte, 16+32)
    copy(combined[:16], salt)
    copy(combined[16:], hash)
    
    return hex.EncodeToString(combined), nil
}

func CheckPasswordArgon2(password, hash string) bool {
    decoded, err := hex.DecodeString(hash)
    if err != nil || len(decoded) != 48 {
        return false
    }
    
    salt := decoded[:16]
    storedHash := decoded[16:]
    
    computedHash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)
    return hmac.Equal(storedHash, computedHash)
}

// SHA-256 hashing
func SHA256(data string) string {
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}

// SHA-512 hashing
func SHA512(data string) string {
    hash := sha512.Sum512([]byte(data))
    return hex.EncodeToString(hash[:])
}

// HMAC-SHA256
func HMACSHA256(data, key string) string {
    h := hmac.New(sha256.New, []byte(key))
    h.Write([]byte(data))
    return hex.EncodeToString(h.Sum(nil))
}

// HMAC-SHA512
func HMACSHA512(data, key string) string {
    h := hmac.New(sha512.New, []byte(key))
    h.Write([]byte(data))
    return hex.EncodeToString(h.Sum(nil))
}
```

### File Hashing

```go
// pkg/utils/file_hash.go
package utils

import (
    "crypto/md5"
    "crypto/sha1"
    "crypto/sha256"
    "crypto/sha512"
    "encoding/hex"
    "io"
    "os"
)

func MD5File(filePath string) (string, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return "", err
    }
    defer file.Close()
    
    hash := md5.New()
    if _, err := io.Copy(hash, file); err != nil {
        return "", err
    }
    
    return hex.EncodeToString(hash.Sum(nil)), nil
}

func SHA1File(filePath string) (string, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return "", err
    }
    defer file.Close()
    
    hash := sha1.New()
    if _, err := io.Copy(hash, file); err != nil {
        return "", err
    }
    
    return hex.EncodeToString(hash.Sum(nil)), nil
}

func SHA256File(filePath string) (string, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return "", err
    }
    defer file.Close()
    
    hash := sha256.New()
    if _, err := io.Copy(hash, file); err != nil {
        return "", err
    }
    
    return hex.EncodeToString(hash.Sum(nil)), nil
}
```

## Encryption Functions

### AES-256-GCM Encryption

```go
// pkg/utils/encrypt.go
package utils

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "errors"
    "io"
)

func EncryptAES256GCM(plaintext, key string) (string, error) {
    // Convert key to 32 bytes
    keyBytes := []byte(key)
    if len(keyBytes) != 32 {
        return "", errors.New("key must be 32 bytes long")
    }
    
    // Create cipher
    block, err := aes.NewCipher(keyBytes)
    if err != nil {
        return "", err
    }
    
    // Create GCM
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    // Generate nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    // Encrypt
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func DecryptAES256GCM(ciphertext, key string) (string, error) {
    // Decode base64
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    // Convert key to 32 bytes
    keyBytes := []byte(key)
    if len(keyBytes) != 32 {
        return "", errors.New("key must be 32 bytes long")
    }
    
    // Create cipher
    block, err := aes.NewCipher(keyBytes)
    if err != nil {
        return "", err
    }
    
    // Create GCM
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    // Extract nonce
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("ciphertext too short")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    
    // Decrypt
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}
```

### Base64 Encoding/Decoding

```go
// pkg/utils/base64.go
package utils

import (
    "encoding/base64"
    "strings"
)

func EncodeBase64(data string) string {
    return base64.StdEncoding.EncodeToString([]byte(data))
}

func DecodeBase64(data string) (string, error) {
    decoded, err := base64.StdEncoding.DecodeString(data)
    return string(decoded), err
}

func EncodeBase64URL(data string) string {
    return base64.URLEncoding.EncodeToString([]byte(data))
}

func DecodeBase64URL(data string) (string, error) {
    decoded, err := base64.URLEncoding.DecodeString(data)
    return string(decoded), err
}

func EncodeBase64URLSafe(data string) string {
    encoded := base64.URLEncoding.EncodeToString([]byte(data))
    return strings.TrimRight(encoded, "=")
}

func DecodeBase64URLSafe(data string) (string, error) {
    // Add padding if needed
    switch len(data) % 4 {
    case 2:
        data += "=="
    case 3:
        data += "="
    }
    
    decoded, err := base64.URLEncoding.DecodeString(data)
    return string(decoded), err
}
```

## String Utilities

### String Manipulation

```go
// pkg/utils/string.go
package utils

import (
    "crypto/rand"
    "math/big"
    "regexp"
    "strings"
    "unicode"
)

// Generate random string
func GenerateRandomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, length)
    for i := range b {
        num, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
        b[i] = charset[num.Int64()]
    }
    return string(b)
}

// Generate random bytes
func GenerateRandomBytes(length int) []byte {
    bytes := make([]byte, length)
    rand.Read(bytes)
    return bytes
}

// Slugify string
func Slugify(s string) string {
    // Convert to lowercase
    s = strings.ToLower(s)
    
    // Replace spaces and special characters with hyphens
    reg := regexp.MustCompile(`[^a-z0-9]+`)
    s = reg.ReplaceAllString(s, "-")
    
    // Remove leading/trailing hyphens
    s = strings.Trim(s, "-")
    
    return s
}

// Truncate string
func Truncate(s string, length int) string {
    if len(s) <= length {
        return s
    }
    return s[:length] + "..."
}

// Truncate words
func TruncateWords(s string, wordCount int) string {
    words := strings.Fields(s)
    if len(words) <= wordCount {
        return s
    }
    return strings.Join(words[:wordCount], " ") + "..."
}

// Capitalize first letter
func Capitalize(s string) string {
    if len(s) == 0 {
        return s
    }
    runes := []rune(s)
    runes[0] = unicode.ToUpper(runes[0])
    return string(runes)
}

// Title case
func TitleCase(s string) string {
    words := strings.Fields(s)
    for i, word := range words {
        words[i] = Capitalize(word)
    }
    return strings.Join(words, " ")
}

// Snake case
func SnakeCase(s string) string {
    var result []rune
    for i, r := range s {
        if unicode.IsUpper(r) && i > 0 {
            result = append(result, '_')
        }
        result = append(result, unicode.ToLower(r))
    }
    return string(result)
}

// Camel case
func CamelCase(s string) string {
    words := strings.Fields(strings.ReplaceAll(s, "_", " "))
    if len(words) == 0 {
        return ""
    }
    
    result := strings.ToLower(words[0])
    for _, word := range words[1:] {
        result += Capitalize(word)
    }
    return result
}

// Pascal case
func PascalCase(s string) string {
    words := strings.Fields(strings.ReplaceAll(s, "_", " "))
    result := ""
    for _, word := range words {
        result += Capitalize(word)
    }
    return result
}

// Remove duplicates from slice
func RemoveDuplicates(slice []string) []string {
    keys := make(map[string]bool)
    result := []string{}
    
    for _, item := range slice {
        if !keys[item] {
            keys[item] = true
            result = append(result, item)
        }
    }
    
    return result
}

// Check if string is empty
func IsEmpty(s string) bool {
    return strings.TrimSpace(s) == ""
}

// Check if string is not empty
func IsNotEmpty(s string) bool {
    return !IsEmpty(s)
}

// Generate UUID
func GenerateUUID() string {
    return uuid.New().String()
}

// Generate short UUID
func GenerateShortUUID() string {
    return strings.ReplaceAll(GenerateUUID(), "-", "")[:12]
}
```

### String Validation

```go
// pkg/utils/validation.go
package utils

import (
    "regexp"
    "strings"
)

// Email validation
func IsValidEmail(email string) bool {
    pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
    matched, _ := regexp.MatchString(pattern, email)
    return matched
}

// Phone validation
func IsValidPhone(phone string) bool {
    // Remove all non-digit characters
    digits := regexp.MustCompile(`\D`).ReplaceAllString(phone, "")
    return len(digits) >= 10 && len(digits) <= 15
}

// URL validation
func IsValidURL(url string) bool {
    pattern := `^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$`
    matched, _ := regexp.MatchString(pattern, url)
    return matched
}

// Strong password validation
func IsStrongPassword(password string) bool {
    if len(password) < 8 {
        return false
    }
    
    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasDigit := regexp.MustCompile(`[0-9]`).MatchString(password)
    hasSpecial := regexp.MustCompile(`[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]`).MatchString(password)
    
    return hasUpper && hasLower && hasDigit && hasSpecial
}

// Username validation
func IsValidUsername(username string) bool {
    if len(username) < 3 || len(username) > 20 {
        return false
    }
    
    pattern := `^[a-zA-Z0-9_]+$`
    matched, _ := regexp.MatchString(pattern, username)
    return matched
}

// Slug validation
func IsValidSlug(slug string) bool {
    if slug == "" {
        return true // Allow empty for optional fields
    }
    
    pattern := `^[a-z0-9-]+$`
    matched, _ := regexp.MatchString(pattern, slug)
    return matched
}
```

## Time Utilities

### Time Handling

```go
// pkg/utils/time.go
package utils

import (
    "time"
    "fmt"
)

// Parse duration with support for days
func ParseDuration(s string) (time.Duration, error) {
    if s == "" {
        return 0, nil
    }
    
    // Handle days
    if strings.HasSuffix(s, "d") {
        days, err := strconv.Atoi(strings.TrimSuffix(s, "d"))
        if err != nil {
            return 0, err
        }
        return time.Duration(days) * 24 * time.Hour, nil
    }
    
    // Handle plain numbers as seconds
    if _, err := strconv.Atoi(s); err == nil {
        seconds, _ := strconv.Atoi(s)
        return time.Duration(seconds) * time.Second, nil
    }
    
    // Use standard time.ParseDuration
    return time.ParseDuration(s)
}

// Format duration in human readable format
func FormatDuration(d time.Duration) string {
    if d < time.Minute {
        return fmt.Sprintf("%.0fs", d.Seconds())
    } else if d < time.Hour {
        return fmt.Sprintf("%.0fm", d.Minutes())
    } else if d < 24*time.Hour {
        return fmt.Sprintf("%.1fh", d.Hours())
    } else {
        days := d.Hours() / 24
        return fmt.Sprintf("%.1fd", days)
    }
}

// Get timezone offset
func GetTimezoneOffset(tz string) (int, error) {
    loc, err := time.LoadLocation(tz)
    if err != nil {
        return 0, err
    }
    
    now := time.Now().In(loc)
    _, offset := now.Zone()
    return offset, nil
}

// Format time in different formats
func FormatTime(t time.Time, format string) string {
    switch format {
    case "rfc3339":
        return t.Format(time.RFC3339)
    case "rfc822":
        return t.Format(time.RFC822)
    case "rfc1123":
        return t.Format(time.RFC1123)
    case "unix":
        return fmt.Sprintf("%d", t.Unix())
    case "unix_milli":
        return fmt.Sprintf("%d", t.UnixMilli())
    case "unix_micro":
        return fmt.Sprintf("%d", t.UnixMicro())
    case "unix_nano":
        return fmt.Sprintf("%d", t.UnixNano())
    default:
        return t.Format(format)
    }
}

// Human readable time ago
func TimeAgo(t time.Time) string {
    now := time.Now()
    diff := now.Sub(t)
    
    if diff < time.Minute {
        return "just now"
    } else if diff < time.Hour {
        minutes := int(diff.Minutes())
        if minutes == 1 {
            return "1 minute ago"
        }
        return fmt.Sprintf("%d minutes ago", minutes)
    } else if diff < 24*time.Hour {
        hours := int(diff.Hours())
        if hours == 1 {
            return "1 hour ago"
        }
        return fmt.Sprintf("%d hours ago", hours)
    } else if diff < 7*24*time.Hour {
        days := int(diff.Hours() / 24)
        if days == 1 {
            return "1 day ago"
        }
        return fmt.Sprintf("%d days ago", days)
    } else if diff < 30*24*time.Hour {
        weeks := int(diff.Hours() / (7 * 24))
        if weeks == 1 {
            return "1 week ago"
        }
        return fmt.Sprintf("%d weeks ago", weeks)
    } else if diff < 365*24*time.Hour {
        months := int(diff.Hours() / (30 * 24))
        if months == 1 {
            return "1 month ago"
        }
        return fmt.Sprintf("%d months ago", months)
    } else {
        years := int(diff.Hours() / (365 * 24))
        if years == 1 {
            return "1 year ago"
        }
        return fmt.Sprintf("%d years ago", years)
    }
}

// Get start of day
func StartOfDay(t time.Time) time.Time {
    year, month, day := t.Date()
    return time.Date(year, month, day, 0, 0, 0, 0, t.Location())
}

// Get end of day
func EndOfDay(t time.Time) time.Time {
    year, month, day := t.Date()
    return time.Date(year, month, day, 23, 59, 59, 999999999, t.Location())
}

// Get start of week
func StartOfWeek(t time.Time) time.Time {
    weekday := int(t.Weekday())
    if weekday == 0 {
        weekday = 7 // Sunday = 7
    }
    return StartOfDay(t.AddDate(0, 0, -weekday+1))
}

// Get end of week
func EndOfWeek(t time.Time) time.Time {
    weekday := int(t.Weekday())
    if weekday == 0 {
        weekday = 7 // Sunday = 7
    }
    return EndOfDay(t.AddDate(0, 0, 7-weekday))
}

// Get start of month
func StartOfMonth(t time.Time) time.Time {
    year, month, _ := t.Date()
    return time.Date(year, month, 1, 0, 0, 0, 0, t.Location())
}

// Get end of month
func EndOfMonth(t time.Time) time.Time {
    year, month, _ := t.Date()
    return time.Date(year, month+1, 0, 23, 59, 59, 999999999, t.Location())
}
```

## Pagination Utilities

### Pagination Helpers

```go
// pkg/utils/pagination.go
package utils

import (
    "math"
    "strconv"
)

type PaginationMeta struct {
    CurrentPage int   `json:"current_page"`
    PerPage     int   `json:"per_page"`
    Total       int64 `json:"total"`
    LastPage    int   `json:"last_page"`
    From        int   `json:"from"`
    To          int   `json:"to"`
    HasMore     bool  `json:"has_more"`
}

type PaginationLinks struct {
    First string `json:"first"`
    Last  string `json:"last"`
    Prev  string `json:"prev"`
    Next  string `json:"next"`
}

type PaginationResponse struct {
    Data       interface{}     `json:"data"`
    Pagination PaginationMeta  `json:"pagination"`
    Links      PaginationLinks `json:"links"`
}

func NewPagination(page, perPage int, total int64) PaginationMeta {
    if page < 1 {
        page = 1
    }
    if perPage < 1 {
        perPage = 15
    }
    
    lastPage := int(math.Ceil(float64(total) / float64(perPage)))
    if lastPage < 1 {
        lastPage = 1
    }
    
    from := (page - 1) * perPage + 1
    to := page * perPage
    if to > int(total) {
        to = int(total)
    }
    
    return PaginationMeta{
        CurrentPage: page,
        PerPage:     perPage,
        Total:       total,
        LastPage:    lastPage,
        From:        from,
        To:          to,
        HasMore:     page < lastPage,
    }
}

func GeneratePaginationLinks(baseURL string, meta PaginationMeta) PaginationLinks {
    links := PaginationLinks{}
    
    // First page
    links.First = fmt.Sprintf("%s?page=1&per_page=%d", baseURL, meta.PerPage)
    
    // Last page
    links.Last = fmt.Sprintf("%s?page=%d&per_page=%d", baseURL, meta.LastPage, meta.PerPage)
    
    // Previous page
    if meta.CurrentPage > 1 {
        links.Prev = fmt.Sprintf("%s?page=%d&per_page=%d", baseURL, meta.CurrentPage-1, meta.PerPage)
    }
    
    // Next page
    if meta.HasMore {
        links.Next = fmt.Sprintf("%s?page=%d&per_page=%d", baseURL, meta.CurrentPage+1, meta.PerPage)
    }
    
    return links
}

func ParsePaginationParams(c *fiber.Ctx) (page, perPage int) {
    page, _ = strconv.Atoi(c.Query("page", "1"))
    perPage, _ = strconv.Atoi(c.Query("per_page", "15"))
    
    if page < 1 {
        page = 1
    }
    if perPage < 1 || perPage > 100 {
        perPage = 15
    }
    
    return page, perPage
}
```

## Sorting Utilities

### Multi-field Sorting

```go
// pkg/utils/sorting.go
package utils

import (
    "reflect"
    "sort"
    "strings"
)

type SortField struct {
    Field string
    Order string // "asc" or "desc"
}

func ParseSortParams(sortStr string) []SortField {
    if sortStr == "" {
        return []SortField{}
    }
    
    var fields []SortField
    parts := strings.Split(sortStr, ",")
    
    for _, part := range parts {
        part = strings.TrimSpace(part)
        if part == "" {
            continue
        }
        
        field := SortField{Field: part, Order: "asc"}
        
        if strings.HasPrefix(part, "-") {
            field.Field = part[1:]
            field.Order = "desc"
        }
        
        fields = append(fields, field)
    }
    
    return fields
}

func SortSlice(slice interface{}, fields []SortField) {
    if len(fields) == 0 {
        return
    }
    
    sort.Slice(slice, func(i, j int) bool {
        for _, field := range fields {
            result := compareFields(slice, i, j, field.Field)
            if result != 0 {
                if field.Order == "desc" {
                    return result > 0
                }
                return result < 0
            }
        }
        return false
    })
}

func compareFields(slice interface{}, i, j int, fieldName string) int {
    v := reflect.ValueOf(slice)
    if v.Kind() != reflect.Slice {
        return 0
    }
    
    elem1 := v.Index(i)
    elem2 := v.Index(j)
    
    if elem1.Kind() == reflect.Ptr {
        elem1 = elem1.Elem()
    }
    if elem2.Kind() == reflect.Ptr {
        elem2 = elem2.Elem()
    }
    
    field1 := elem1.FieldByName(fieldName)
    field2 := elem2.FieldByName(fieldName)
    
    if !field1.IsValid() || !field2.IsValid() {
        return 0
    }
    
    switch field1.Kind() {
    case reflect.String:
        return strings.Compare(field1.String(), field2.String())
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if field1.Int() < field2.Int() {
            return -1
        } else if field1.Int() > field2.Int() {
            return 1
        }
        return 0
    case reflect.Float32, reflect.Float64:
        if field1.Float() < field2.Float() {
            return -1
        } else if field1.Float() > field2.Float() {
            return 1
        }
        return 0
    case reflect.Bool:
        if field1.Bool() == field2.Bool() {
            return 0
        } else if field1.Bool() {
            return 1
        }
        return -1
    }
    
    return 0
}
```

## File Utilities

### File Operations

```go
// pkg/utils/file.go
package utils

import (
    "io"
    "os"
    "path/filepath"
    "strings"
)

// Get file extension
func GetFileExtension(filename string) string {
    return strings.ToLower(filepath.Ext(filename))
}

// Get file size
func GetFileSize(filePath string) (int64, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return 0, err
    }
    defer file.Close()
    
    stat, err := file.Stat()
    if err != nil {
        return 0, err
    }
    
    return stat.Size(), nil
}

// Check if file exists
func FileExists(filePath string) bool {
    _, err := os.Stat(filePath)
    return !os.IsNotExist(err)
}

// Create directory if not exists
func EnsureDir(dirPath string) error {
    if !FileExists(dirPath) {
        return os.MkdirAll(dirPath, 0755)
    }
    return nil
}

// Copy file
func CopyFile(src, dst string) error {
    sourceFile, err := os.Open(src)
    if err != nil {
        return err
    }
    defer sourceFile.Close()
    
    destFile, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destFile.Close()
    
    _, err = io.Copy(destFile, sourceFile)
    return err
}

// Get MIME type
func GetMIMEType(filePath string) string {
    ext := GetFileExtension(filePath)
    
    mimeTypes := map[string]string{
        ".txt":  "text/plain",
        ".html": "text/html",
        ".css":  "text/css",
        ".js":   "application/javascript",
        ".json": "application/json",
        ".xml":  "application/xml",
        ".pdf":  "application/pdf",
        ".jpg":  "image/jpeg",
        ".jpeg": "image/jpeg",
        ".png":  "image/png",
        ".gif":  "image/gif",
        ".svg":  "image/svg+xml",
        ".mp4":  "video/mp4",
        ".mp3":  "audio/mpeg",
        ".zip":  "application/zip",
    }
    
    if mimeType, exists := mimeTypes[ext]; exists {
        return mimeType
    }
    
    return "application/octet-stream"
}

// Format file size
func FormatFileSize(bytes int64) string {
    const unit = 1024
    if bytes < unit {
        return fmt.Sprintf("%d B", bytes)
    }
    
    div, exp := int64(unit), 0
    for n := bytes / unit; n >= unit; n /= unit {
        div *= unit
        exp++
    }
    
    units := []string{"KB", "MB", "GB", "TB", "PB"}
    return fmt.Sprintf("%.1f %s", float64(bytes)/float64(div), units[exp])
}
```

## CLI Utilities

### Command Line Helpers

```go
// pkg/utils/cli.go
package utils

import (
    "fmt"
    "os"
    "strings"
)

// Print colored output
func PrintSuccess(message string) {
    fmt.Printf("\033[32m✓ %s\033[0m\n", message)
}

func PrintError(message string) {
    fmt.Printf("\033[31m✗ %s\033[0m\n", message)
}

func PrintWarning(message string) {
    fmt.Printf("\033[33m⚠ %s\033[0m\n", message)
}

func PrintInfo(message string) {
    fmt.Printf("\033[34mℹ %s\033[0m\n", message)
}

// Ask for user input
func AskInput(prompt string) string {
    fmt.Print(prompt + ": ")
    var input string
    fmt.Scanln(&input)
    return strings.TrimSpace(input)
}

// Ask for confirmation
func AskConfirmation(prompt string) bool {
    response := AskInput(prompt + " (y/N)")
    return strings.ToLower(response) == "y" || strings.ToLower(response) == "yes"
}

// Progress bar
func ShowProgress(current, total int, message string) {
    percentage := float64(current) / float64(total) * 100
    barLength := 50
    filledLength := int(percentage / 100 * float64(barLength))
    
    bar := strings.Repeat("=", filledLength) + strings.Repeat("-", barLength-filledLength)
    
    fmt.Printf("\r%s [%s] %.1f%% (%d/%d)", message, bar, percentage, current, total)
    
    if current == total {
        fmt.Println()
    }
}
```

## Usage Examples

### In Controllers

```go
// app/controllers/user_controller.go
func (c *UserController) Create(ctx *fiber.Ctx) error {
    req := ctx.Locals("validated_data").(*schemas.CreateUserRequest)
    
    // Hash password
    hashedPassword, err := utils.HashPassword(req.Password)
    if err != nil {
        return ctx.Status(500).JSON(fiber.Map{"error": "Failed to hash password"})
    }
    
    // Generate slug
    slug := utils.Slugify(req.Name)
    
    // Create user
    user := &models.User{
        Email:    req.Email,
        Password: hashedPassword,
        Name:     req.Name,
        Slug:     slug,
    }
    
    // Save to database
    if err := c.userService.Create(user); err != nil {
        return ctx.Status(400).JSON(fiber.Map{"error": err.Error()})
    }
    
    return ctx.Status(201).JSON(schemas.UserResponse{
        ID:        user.ID,
        Email:     user.Email,
        Name:      user.Name,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
    })
}
```

### In Services

```go
// app/services/user_service.go
func (s *UserService) Create(req schemas.CreateUserRequest) (*models.User, error) {
    // Validate email
    if !utils.IsValidEmail(req.Email) {
        return nil, errors.New("invalid email format")
    }
    
    // Check if user exists
    if s.userRepo.ExistsByEmail(req.Email) {
        return nil, errors.New("user already exists")
    }
    
    // Hash password
    hashedPassword, err := utils.HashPassword(req.Password)
    if err != nil {
        return nil, err
    }
    
    // Generate UUID
    id := utils.GenerateUUID()
    
    // Create user
    user := &models.User{
        ID:       id,
        Email:    req.Email,
        Password: hashedPassword,
        Name:     req.Name,
        Slug:     utils.Slugify(req.Name),
    }
    
    return s.userRepo.Create(user)
}
```

## Best Practices

### 1. **Security**
- Use strong hashing algorithms (Argon2, bcrypt)
- Generate cryptographically secure random strings
- Validate all input data
- Use proper encryption for sensitive data

### 2. **Performance**
- Cache expensive operations
- Use appropriate data structures
- Avoid unnecessary string operations
- Optimize file operations

### 3. **Error Handling**
- Always handle errors properly
- Provide meaningful error messages
- Log errors appropriately
- Use proper error types

### 4. **Testing**
- Write unit tests for all utilities
- Test edge cases and error conditions
- Use test data that covers all scenarios
- Mock external dependencies

## Next Steps

- [Authentication System](/docs/authentication/jwt)
- [File Storage](/docs/storage/overview)
- [Testing](/docs/contributing/testing)
- [CLI Commands](/docs/cli/overview)
